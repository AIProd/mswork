The video discusses the case of Bernhard Runker, who developed severe pain due to Hepatitis E, a liver inflammation transmitted from animals to humans, diagnosed at the University Clinic in Basel. Key points include the transmission of Hepatitis E through contaminated water and undercooked meat, Bernhard's treatment involving medications and therapy leading to recovery, and preventive measures like proper food handling and hygiene to avoid the virus. Despite Hepatitis E being rare in Switzerland, awareness and prompt medical intervention for symptoms are emphasized.


Introduction: 
This video is about Bernhard Runker, who began to struggle with severe pain in his shoulders, chest, arms, and hands five years ago. Tests at the University Clinic in Basel led to a diagnosis of Hepatitis E, a form of hepatitis that is transmitted from animals to humans. 

Main Ideas:

- Hepatitis E is a form of hepatitis, an inflammation of the liver, which is transmitted from animals to humans. It is different from other types of hepatitis in this regard.
- Most people with Hepatitis E notice nothing, while some, like Bernhard, suffer from severe pain and discomfort.
- Hepatitis E can be transmitted through contaminated water and meat products. It is particularly important to thoroughly cook meat in order to inactivate the virus.
- Bernhard received strong medications and cortisone for the pain. He also began physio and occupational therapy to stimulate the nerves in the affected body parts.
- After several months of treatment, the feeling returned to his fingers and he was able to use his hand normally again.
- It is still unclear how Bernhard contracted the virus. To avoid a recurrence, he is now very careful about what he eats.

Conclusion:
Although Hepatitis E is not very common in Switzerland, it's important to know how the virus is transmitted in order to protect oneself. This includes thoroughly cooking meat and practicing proper hygiene. Individuals who experience severe pain or other symptoms should seek medical attention immediately. 

Title: Bernhard's Battle Against Hepatitis E: A Path to Recovery


https://docs.google.com/presentation/d/1o0NVoEDpvN-BuLCXRrBnWt5W3DYw3SVw/edit?usp=sharing&ouid=115761606175286406693&rtpof=true&sd=true

import pandas as pd
import sqlite3

# Load CSV files into pandas DataFrames
df1 = pd.read_csv('file1.csv')
df2 = pd.read_csv('file2.csv')

# Create a SQLite database
conn = sqlite3.connect('example.db')

# Convert the DataFrames to SQL tables
df1.to_sql('table1', conn, if_exists='replace', index=False)
df2.to_sql('table2', conn, if_exists='replace', index=False)

# Close the connection to the database
conn.close()



These definitions are based on common terms used in pharmaceutical sales and CRM (Customer Relationship Management) systems:

pk_mdm_key: Primary key or unique identifier used in the Master Data Management (MDM) system to uniquely identify records.

customer_territory_name: Name or identifier of the geographic or organizational territory assigned to a customer.

customer_target: The sales or engagement target set for a customer or a group of customers.

emp_name: Name of the employee, typically referring to the sales representative or account manager.

emp_department: Department within the organization to which the employee belongs.

customer_bu: Customer's business unit, referring to the specific division or sector of the customer's organization.

customer_franchise: The franchise or product line that the customer is associated with within the pharmaceutical company's offerings.

customer_bu_code: A unique code or identifier for the customer's business unit.

customer_franchise_code: A unique code or identifier for the customer's franchise.

int_channel: The channel through which an interaction with a customer was conducted (e.g., phone, email, face-to-face).

int_type: Type of interaction (e.g., sales call, service request, feedback).

int_subtype: More specific categorization of the interaction type (e.g., initial contact, follow-up, complaint).

taxonomy_key: A categorization key that helps in classifying the interaction based on predefined taxonomy (e.g., product inquiry, service issue).

int_title: Title or subject of the interaction.

event_participant_role: Role of the participant in the interaction (e.g., decision-maker, influencer, user).

contact_mdm_id: Unique identifier for the contact in the Master Data Management system.

case_prod_key: Key or identifier linking the interaction or case to a specific product.

key_description: Description associated with the case_prod_key, providing details about the product or case.

cases_date: Date of the interaction or case creation.

int_rejection: Indicator or details regarding whether the interaction was rejected by the customer.

int_acceptation: Indicator or details regarding whether the interaction was accepted by the customer.

int_reaction: Customer's reaction or response to the interaction.

total_opens: Total number of times the customer opened an email or document related to the interaction.

total_actions: Total actions taken by the customer as a result of the interaction.

planned_call_flag: Indicator whether the interaction was a planned call or meeting.

ean: European Article Number, which might be used here as a unique identifier for products.

units: Quantity of products discussed or sold during the interaction.

sales: Revenue or sales amount associated with the interaction or transaction.

sales_channel: The sales channel through which the product was sold or the interaction occurred (e.g., direct, online, distributor).

country_code: Country code representing the geographical location associated with the interaction or sales transaction.

https://medium.com/@c.giancaterino/langchain-openai-in-action-with-different-data-sources-e089ca43c90a

brand_name: Name of the product brand involved in the interaction or sales.

mdm_key: Another unique identifier used within the Master Data Management system, possibly linking different tables or records.

customernameh2: Possibly a secondary customer name or an alternative identifier for the customer.




from langchain_community.vectorstores import FAISS
from langchain_community.document_loaders import TextLoader
from langchain_openai import OpenAIEmbeddings
from langchain.text_splitters import CharacterTextSplitter

# This function replaces CVStoVectorStoreIndex
def CSVtoFAISSIndex(dataframe):
    # Convert DataFrame to a list of documents (assuming each row is a document)
    documents = dataframe.to_dict('records')  # Convert each row to a dictionary

    # Initialize OpenAI embeddings (ensure your OPENAI_API_KEY is set)
    embeddings = OpenAIEmbeddings()

    # Split documents into chunks if they are too large (optional, adjust based on your needs)
    text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0)
    docs = text_splitter.split_documents(documents)

    # Create FAISS index from documents
    vectorstore = FAISS.from_documents(docs, embeddings)

    return vectorstore


def main():
    # Create a log directory if it doesn't exist
    log_directory = "logs"
    if not os.path.exists(log_directory):
        os.makedirs(log_directory)
    
    # Configure logging
    log_filename = datetime.now().strftime('%Y-%m-%d_%H-%M-%S') + '.log'
    log_filepath = os.path.join(log_directory, log_filename)
    logging.basicConfig(
        filename=log_filepath,
        filemode='a',
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        level=logging.DEBUG
    )

# Initialize variables for email content
email_subject = f"Summary of Insights for {role} in {industry}"
email_body_intro = f"""
Hi Team,

Please find below the summary of insights we've gathered based on the recent analysis for the role of {role} in the {industry} industry.

"""

# Start with the introduction for the email body content
email_body_content = email_body_intro

# Loop through each question and answer
for i, k in enumerate(list_from_string):
    # Assuming this method synchronously returns the answer as a string
    answer = gpt4_agent.run(k)  
    # Print question and answer in the Streamlit app
    st.markdown(
        f"<div class='slack-container'><div class='slack-question'>Question {i + 1}: {k}</div><div class='slack-answer'>{answer}</div></div>",
        unsafe_allow_html=True,
    )
    # Append question and answer to the email body content
    email_body_content += f"Question {i + 1}: {k}\nAnswer: {answer}\n\n"

# Wrap up the email with a closing
email_body_content += "Best regards,\n[Your Name]\n"

# Display the email format in the app
st.subheader("Email Format Summary")
st.text_area("Email Subject", email_subject, height=50)
st.text_area("Email Body", email_body_content, height=400)
