def explode_and_clean(df, column):
    # Flatten the lists if they are nested
    df[column] = df[column].apply(lambda x: [item for sublist in x for item in sublist] if isinstance(x, list) and any(isinstance(i, list) for i in x) else x)
    # Explode the column
    df = df.explode(column).reset_index(drop=True)
    # Replace empty strings and NaNs with pd.NA
    df[column] = df[column].replace([np.nan, '', 'nan'], pd.NA)
    # Drop rows where the column is NaN
    return df.dropna(subset=[column])

# Applying the function
interaction_data_cleaned = explode_and_clean(interaction_data, 'brand_name')
df = pd.DataFrame(data)

# Function to explode 'brand_name' column and remove NaNs and empty strings
def explode_and_clean(df, column):
    # Ensure the column is of type list if not already
    df[column] = df[column].apply(lambda x: x if isinstance(x, list) else [x])
    # Explode the column
    df = df.explode(column).reset_index(drop=True)
    # Replace empty strings with NaN and drop rows where column is NaN
    df[column] = df[column].replace('', pd.NA)
    return df.dropna(subset=[column])

# Applying the function
df_cleaned = explode_and_clean(df, 'brand_name')

# Save the cleaned DataFrame to a CSV file
df_cleaned.to_csv('/mnt/data/cleaned_dataframe.csv', index=False)

# Display the cleaned DataFrame
print(df_cleaned)











def explode_and_clean(df, column):
    df = df.explode(column).reset_index(drop=True)
    df[column] = df[column].replace('', pd.NA)
    return df.dropna(subset=[column])





def explode_and_clean(df, column):
    df[column] = df[column].apply(lambda x: [i for i in x if pd.notna(i)] if isinstance(x, list) else x)
    df = df.explode(column).reset_index(drop=True)
    df[column] = df[column].replace('', pd.NA)
    return df.dropna(subset=[column])



def explode_and_clean(df, column):
    df = df.explode(column).reset_index(drop=True)
    df[column] = df[column].replace('', pd.NA)
    return df.dropna(subset=[column])

# Applying the function
df_cleaned = explode_and_clean(df, 'brand_name')


ADDERSS(ROW(D3);COLUMN(D3);4)

SUBSTITUTE(ADDRESS(ROW(),COLUMN()),"$","")

def clean_finding_text(finding_text):
    # Remove escape characters and unnecessary backslashes
    cleaned_text = finding_text.replace("\\n", "\n").replace("\\", "").replace('\"', '"').replace("'", "")
    
    # Remove curly brackets and format the text
    cleaned_text = cleaned_text.strip('{}')
    
    # Split the text into lines and format it in a readable manner
    lines = cleaned_text.split("\n")
    formatted_lines = [line.strip() for line in lines if line.strip()]
    
    # Join the lines into a formatted string
    formatted_text = "\n".join(formatted_lines)
    
    return formatted_text







def clean_finding_text(finding_text):
    # Remove escape characters and unnecessary backslashes
    cleaned_text = finding_text.replace("\\n", "\n").replace("\\", "").replace('\'', '')

    # Convert the cleaned string to a dictionary and format it
    cleaned_text = eval(cleaned_text)
    
    # Format the dictionary into a readable string
    formatted_text = ""
    for key, value in cleaned_text.items():
        formatted_text += f"{key}:\n{value}\n\n"
    
    return formatted_text.strip()

# Apply the function to the 'Finding' column
df['Formatted Finding'] = df['Finding'].apply(clean_finding_text)






def clean_finding_text(finding_text):
    # Remove escape characters and unnecessary backslashes
    cleaned_text = finding_text.replace("\\n", "\n").replace("\\", "").replace('\'', '')
    
    # Split the text into lines and format it in a readable manner
    lines = cleaned_text.split("\n")
    formatted_lines = [line.strip() for line in lines if line.strip()]
    
    # Join the lines into a formatted string
    formatted_text = "\n".join(formatted_lines)
    
    return formatted_text

# Apply the function to the 'Finding' column
df['Formatted Finding'] = df['Finding'].apply(clean_finding_text)
